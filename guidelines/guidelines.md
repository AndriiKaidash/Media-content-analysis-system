# Методичні вказівки до виконання лабораторних робіт

для студентів напряму підготовки  
123 Комп’ютерна інженерія
всіх форм навчання

## Виявлення вимог до функціональності програми. Розробка запитів зацікавлених осіб

**Мета:** вивчення вимог до програмного проекту, структури документів та
програмної системи, формування запитів зацікавлених осіб.

**Довідка**

Розробка концептуальної моделі предметної області є першим найважливішим етапом
розробки програмної системи, оскільки визначає узагальнене уявлення про
інформацію її кінцевих користувачів.

**Визначення цілі, перетворення системи**

База даних є частиною програмної системи, тому для її розробки необхідно
проаналізувати вимоги до системи в цілому.

**Послідовність дій:**

1.  Аналіз предметної області 

2.  Формування запитів зацікавлених осіб

**Запити зацікавлених осіб** – це опис вимог різних учасників проекту
(замовників, користувачів та ін.) до змісту системи, що містить організаційні
(призначення системи), функціональні (можливості системи) та експлуатаційні
аспекти.

**Структура документів:**

Дивись у ["Аналіз предметної області"](../docs/requirements/state-of-the-art.md) та ["Запити зацікавлених осіб"](../docs/requirements/stakeholders-needs.md).  

**Завдання:**

1. Провести аналіз предметної області

1. Визначити коло зацікавлених осіб

2. Визначити призначення розроблюваної системи за структурою списку запитів
зацікавлених осіб (компетенції, бізнес-сценарії та ін.)

## Питання для самостійної перевірки

1.  Які категоріі користувачів можуть приймати участь у проекті?

2.  Етапи розробки баз даних.

3.  Що означає "концептуальна модель"?

4.  Де визначаються ситуації, що не входять у список передумов?

## Виявлення вимог до функціональності програми. Розробка моделі прецедентів

**Мета:** вивчення вимог до програмного проекту, структури документів та
програмної системи, формування моделі прецедентів.

**Довідка**

Розробка концептуальної моделі предметної області є першим найважливішим етапом
розробки програмної системи, оскільки визначає узагальнене уявлення про
інформацію її кінцевих користувачів.

**Визначення цілі, перетворення системи**

База даних є частиною програмної системи, тому для її розробки необхідно
проаналізувати вимоги до системи в цілому.

**Етапи розробки баз даних:**

2.  Діаграми Use Case

3.  Специфікація, сценарій, Sequence-діаграми

***Прецедент (англ. Use Case)*** – список етапів, що послідовно описує взаємодію
системи з користувачем та використовується для досягнення певної мети,
визначеної дійовою особою (англ. Actor).

Прецеденти слугують для документування функціональних вимог до програмних
систем. Описуючи деякий цілісний фрагмент поведінки системи, прецедент не
вдається в особливості внутрішньої структури суб’єкта. Визначення прецеденту
містить всі властиві йому види поведінки: основну послідовність, різноманітні
варіанти стандартної поведінки та різні виключні ситуації із зазначенням
відповідної реакції на них.

На діаграмах прецедентів в UML Use Case зображується у вигляді еліпса, всередині
якого (або під ним) вказується ім’я елемента.

До прецедентів в UML застосовні наступні види відношень:

- ***Асоціація (англ. Association)*** – вказує на те, що Actor ініціює відповідний
варіант використання.

- ***Розширення (англ. Extend)*** – різновид відношення залежності між базовим
варіантом використання та його частковим випадком.

- ***Включення (англ. Include)*** – визначає зв'язок базового варіанта використання
з іншим, функціональна поведінка якого завжди задіюється базовим варіантом.

- ***Узагальнення (англ. Generalization, наслідування)*** – моделює відповідну
спільність ролей.

***Actor*** – діюча особа (користувач, система, програма), спроможна приймати
рішення та взаємодіяти з розроблюваною системою.

***Діаграма Use Case*** – абстраговане представлення компонентів бази даних, дій та
зв’язків між ними.

***Специфікация*** - це формалізований опис властивостей, характеристик і функцій
об'єктів.

![](media/c5bd823142768c01979ee59925abccc9.png)

3. **Специфікація Use Case**

**ID** (ідентифікаційний номер, що присвоюється прецеденту при розробці системи)

**Назва** (власне, назва прецеденту)

**Учасники** (сторони, що діють за вказаним сценарієм)

**Передумови** (перелік дій, які необхідно виконати перед виконанням даного варіанту використання)

**Результати** (вихідні дані та зміна стану системи)

**Виключні ситуації** (ситуації, що суперечать виконанню передумов)

**Основний сценарій**

**Сутності** (найменші неподільні елементи проекту, що приймають участь у виконанні сценарію)

***Сценарій*** - послідовність дій, що мають бути виконані для досягнення
цілі, показує взаємодію Actor’a з системою у вигляді «користувач виконую дію
над системою» з вказанням результату, що повертає система. Зображується в
UML у вигляді діаграми Sequence.

Сценарій слугує основою для виділення сутності проекту.

**Приклад:**

*ID:* **UC_CreateRegCard**

*Назва:* Створення реєстраційної картки користувача

*Учасники:* Адміністратор, Система

*Передумова:* Адміністратор авторизований в системі

*Виключні ситуації:*

-   Адміністратор не авторизований

    1.  Завантажити сторінку авторизації

*Результат: *Деактивована* *реєстраційна карта нового клієнта.

*Основний сценарій:*

1.  Адміністратор починає взаємодію.

2.  Система створює форму «Новий користувач».

3.  Адміністратор заповнює поля: ім’я, роль, адреса елеткронної пошти, текст
    запрошення.

4.  Система створює деактивовану реєстраційну картку нового користувача.

5.  Система генерує повідомлення запрошення користувача з URL для активації
    реєстраційної картки.

6.  Система пересилає повідомлення.

7.  Система генерує стан виконання операції.

8.  Адміністратор закінчує взаємодію.

*Діаграма:*

![](media/dfda7368f9ff9bb07cbb2d9587b34b30.png)


*Сутності:* Реєстраційна картка, ім’я, роль, адреса елеткронної пошти, текст
запрошення, повідомлення запрошення користувача, URL для активації реєстраційної
картки.

**Завдання:**

1.  На основі аналізу запитів зацікавлених осіб розробити загальну діаграму
    прецедентів

2.  Для кожного прецедента розробити специфікацію

##  Питання для самостійної перевірки

1.  Які категоріі користувачів можуть приймати участь у проекті?

2.  Що представляє собою діаграма Use Сase?

3.  Етапи розробки баз даних.

4.  Які види відношень застосовуються в UML

5.  Де ініціюється і закінчується процес взаємодії відповідно до сценарію
    прецедента?

6.  Яке зображення має прецедент на діаграмі UML?

7.  З яких частин складається специфікація Use Case?

8.  Де визначаються ситуації, що не входять у список передумов?

9.  Які повноваження може мати Actor?

10. На основі чого відбувається виділення сутностей проекту?

11. Яке призначення прецедентів?

12. Які стосунки можливі між актором і елементом Use Case?

#№ Розробка моделі бізнес-об’єктів

**Мета:** Зрозуміти сутність бізнес-моделювання. Отримати навички розробки
моделі бізнес-об’єктів та словника предметної області.

**Довідка**

***Бізнес-моделювання (ділове моделювання)*** - діяльність з формування моделей
організацій, що включає опис ділових об'єктів (підрозділів, посад, ресурсів,
ролей, процесів, операцій, інформаційних систем, носіїв інформації і т.д.) і
вказівка зв'язків між ними. Вимоги до моделей, що формуються та їх відповідне
утримання визначаються цілями моделювання.

Бізнес-моделюванням також називають дисципліну і окремий підпроцес в процесі
розробки програмного забезпечення, в якому описується діяльність компанії та
визначаються вимоги до системи - ті підпроцеси та операції, що підлягають
автоматизації розробки в інформаційній системі.

***Бізнес-об’єкт*** представляє значну і постійну частину інформації, керованої
бізнес-акторами і виконавцями. Бізнес-об’єкти пасивні, тобто, вони не ініціюють
взаємодії самі по собі. Бізнес-об’єкт може бути використаний в безлічі різних
реалізацій бізнес-прецедентів і зазвичай реагує на будь-яку одиничну взаємодію.
Бізнес-об’єкти забезпечують основу для поділу інформації (потоку документів)
серед виконавців, що беруть участь в різних реалізаціях бізнес-прецедентів.

Бізнес-об’єкти являють абстракцію важливої постійної інформації в
бізнес-системі. Будь-яка частина інформації, яка є властивістю чого-небудь ще,
ймовірно не є бізнес-об’єктом в дійсності.

Бізнес-аналітик відповідає за ідентифікацію та опис бізнес-об’єктів, а також за
визначення впливу організаційних змін на інформацію, створену і необхідну
бізнес-системою. Бізнес-об’єкти також використовуються системними аналітиками та
дизайнерами при описі системних прецедентів та ідентифікації програмних об’єктів
відповідно.

Метою моделювання бізнес-об’єктів та їх станів є використання моделей
бізнес-об’єктів та їх станів при проектуванні переліку вхідних / вихідних
сигналів і даних, інтерфейсу користувача, баз даних (БД), класів, які реалізують
функції системи.

Бізнес-об’єкт (business entity), представляє абстракцію суті реального світу.
Прикладами бізнес-об’єктів можуть бути заявка на кредитування, договір, угода і
т.д.

Модель з описом бізнес-об’єктів повинна будуватися на основі опису бізнес-процесів. Бізнес-об’єкти 
повинні моделюватися в розбивці по бізнес-процесам. При
створенні програмної системи моделюватися повинні тільки бізнес-об’єкти,
пов'язані з діяльностями, що підлягають автоматизації.

Для створення опису документів / бізнес-об’єктів використовується компоненти
діаграми класів / функцій:

-   пакет (package);

-   бізнес сутність (business entity);

-   асоціативний зв'язок (association);

-   зв'язок агрегація (agregation);

-   зв'язок композиція (composition);

-   зв'язок спадкування або батько нащадок (generalization).

***Пакет*** використовується для групування бізнес об’єктів.

![](media/a04dfabb76e4bedc8704d33284c56f52.png)

***Елемент бізнес-сутність***

![](media/842bddad8c668b9e19ac40fef2fab898.png)

Бізнес-об’єкти можуть мати атрибути. При описі атрибутів можна зазначати:

-   назву атрибута;

-   тип атрибута;

-   стереотип атрибута;

-   початкове значення атрибута (опціонально);

-   правила формування атрибута;

-   приклади значень атрибута.

![](media/9d1c428e0f8843cb177fee5ceeb50b80.png)

Для завдання типів атрибутів можуть використовуватися типи даних:

-   число;

-   символ;

-   дата;

-   час;

-   логічне значення;

-   об'єкт.

Тип даних «число» можна використовувати для опису чисел будь-якого виду,
наприклад, «число (10.3)». В дужках рекомендується зазначати загальна кількість
цифр числа і якщо потрібно, кількість цифр після крапки.

Тип даних символ можна використовувати для опису рядків символів, наприклад,
«символ (100)».

Тип даних «дата» можна використовувати для атрибутів, які є датами.

Тип даних «час» можна використовувати для атрибутів, які є часом.

Тип даних «логічне значення» можна використовувати для атрибутів, які можуть
приймати два значення, наприклад «істина», «брехня».

Тип даних «об'єкт» можна використовувати для атрибутів, що представляють великий
об'єкт, наприклад креслення, малюнок.

Початкове значення атрибута не є обов'язковим полем.

Якщо значення атрибута можуть задаватися елементом списку, або бути кандидатами
на довідники, словники, то в колонці таблиці початкове значення, пов'язаної з
цим атрибутом, можна зазначатися слово словник, довідник. Якщо атрибут має
початкове значення, то слово словник або довідник можна вказувати через кому
після значення атрибута за замовчуванням.

За атрибутам, за якими буде проводитися угруповання або сортування, наприклад,
для звітів, в описі початкових значень можна додатково вказувати слово параметр
угруповання або сортування.

Атрибути можуть задаватися елементом списку, бути кандидатами на словники,
довідники та одночасно бути атрибутом, за яким проводитиметься угруповання. В
цьому випадку за словом список, або словник, довідник через кому можна
використовувати слово параметр.

Якщо атрибут задається типом даних об'єкт, то початкове значення може задається
як ім'я файлу, в якому зберігатиметься об'єкт, наприклад, малюнок або креслення.

***Асоціативний зв'язок (association)*** між бізнес-сутностями (business entity) є
смисловий зв'язок. Зв'язок не пояснює, як сутності спілкуються один з одним,
відзначається тільки смислова залежність між ними. Асоціативний зв'язок
(association) зображується на діаграмі класів суцільний прямою лінією.

Асоціативний зв'язок може бути пойменований. Ім'я асоціації вказується, виходячи
з контексту. Рекомендується вказувати ім'я асоціації так, щоб воно читалося
коректно зліва направо або зверху вниз.

![](media/d8121c068546f3ee39d5a80d292aa69d.png)

***Зв'язок композиція*** позначає зв'язок частина цілого (part of), де частина не може
існувати без цілого. Наприклад, журнал включає заголовок журналу і рядки
журналу.

Композиція (composition) зображується суцільною прямою лінією з додаванням на
кінці зафарбованого ромба:

![](media/842bddad8c668b9e19ac40fef2fab898.png)

***Зв'язок агрегація*** означає зв'язок частина цілого (part of), де частина може
існувати без цілого (контейнер).

![](media/b8487b0e87e1b9b944076cc7e1f3927b.png)

Кількість бізнес об’єктів, які беруть участь в зв'язку, називається потужністю
зв'язку. Потужність вказується на кожному кінці зв'язку. Потужність означає
число зв'язків між однією бізнес сутністю на початку лінії зв'язку з бізнес
сутностями в кінці лінії зв'язку.

Потужність зв'язку може позначатися таким чином:

-   1 - рівно одна бізнес сутність;

-   0 .. \* - нуль або більше бізнес об’єктів;

-   1 .. \* - одна або більше бізнес об’єктів;

-   0 .. 1 - нуль або одна бізнес сутність;

-   5 .. 8 - специфічний діапазон 5,6,7,8;

-   4 .. 7, 9 - комбінація 4,5,6,7, або 9 бізнес об’єктів.

Потужність зв'язку з боку зафарбованого ромба не слід вказувати, оскільки вона
завжди дорівнює 1 по нотації мови UML.

![](media/5da8a3354736283afa9d2b67d77cc609.png)

***Спадкування*** або зв'язок батько-нащадок (generalization) між бізнес об’єктами -
це таке відношення між ними, коли один бізнес-об’ект повторює структуру іншого
(одиночне спадкоємство) або декількох інших (множинне успадкування)
бізнес-об’єктів.

Зв'язок спадкування (generalization) не називається, на ній також не вказується
потужність.

На діаграмах класів спадкування (generalization) зображується стрілкою з не
зафарбовані трикутником, зверненим до об’єкта, від якої успадковуються
властивості.

![](media/27e4c858c8e0e26ef64a6444bc05dfa8.png)

***Словник предметної області***

Основне завдання на цьому етапі сформувати однозначний термінологічний словник
для предметної області. Деякі об'єкти можна назвати різними словами, наприклад,
«Огляд книги» може мати на увазі те ж саме, що «Редакторський огляд» або «Огляд,
складені користувачем».

Модель предметної області постійно змінюється і повинна відображати поточне
розуміння предметної області.

З використанням словника предметної області має відбуватися спілкування між
учасниками робочої групи. Але модель предметної області краще, ніж словник. Вона
показує графічно, як терміни пов'язані між собою. Проте нам все одно потрібно
створювати словник предметої області, щоб визначити список термінів та їх
пояснень.

**ЗАВДАННЯ**

1.Вивичити основні концепції бізнес моделювання. Вільно володіти термінологією:
бузнес-об’єкт, словник предметної області, їх сутність та призначення.

2.Виділити з Use CASE запити зацікавлених осіб.

3.Виділити об'єкти, над якими відбуівються дії, та їхні атрибути.

4.Визначити співвідношення між вище згаданими компонентами

5.Зробити розбивку на пакети, якщо це необхідно.

6.Побудувати діаграму бізнес-об’єктів.

7.Розробити словник предметної області.

**КОНТРОЛЬНІ ПИТАННЯ**

1.Що таке бізнес моделювання?

2.Призначення бізнес моделювання?

3.Де використовується?

4.Що таке бізнес-сутність?

5.Для чого використовується бізнес-сутність?

6.Як визначити бізнес-сутність?

7.Які існують зв’язки між бізнес-сутностями?

8.Що таке асоціативний зв’язок? Як він відображається?

9.Що таке зв’язок агрегація? Як він відображається?

10.Що таке зв’язок композиція? Як він відображається?

11.Що таке зв’язок спадкування? Як він відображається?

12.Що таке атрибути бізнес-сутості?

13.Для чого існують атрибути бізнес-об’єктів?

14.Що таке словник предметної області?

15. Для чого використовується словник предметної області?

# Розробка реляційної схеми

**МЕТА **

Вивчення структури реляційних таблиць. Методи створення реляційної таблиці.

**ДОВІДКА**

**Реляційна модель даних**

Реляційна модель даних — логічна модель даних, що описує:

-   структури даних у вигляді наборів відношень, що, можливо, змінюються в часі;

-   теоретико-множинні операції над даними: об'єднання, перетин, різниця і
    декартів добуток;

-   спеціальні реляційні операції: селекція, проекція, з'єднання і розподіл;

-   а також спеціальні правила, що забезпечують цілісність даних.

Обробка даних в реляційній моделі ґрунтується на принципах реляційної алгебри.

Реляційна база даних — основана на реляційній моделі даних. Для роботи з
реляційними БД застосовують реляційні СКБД. Інакше кажучи, реляційна база даних
— це база даних, яка сприймається користувачем як набір нормалізованих відношень
різного ступеню.

**Відношення**

Відношення має просту графічну інтерпретацію, воно може буде представлене у
вигляді таблиці, стовпці (поля, атрибути) якої відповідають входженням доменів у
відношення, а рядки (записи, кортежі) - наборам з n значень, що взяті з
початкових доменів. Кількість рядків n, називають кардинальним числом
відношення, або потужністю відношення.

Така таблиця має ряд властивостей:

-   В таблиці немає двох однакових рядків.

-   Таблиця має стовпці, відповідні атрибутам відношення.

-   Кожний атрибут у відношенні має унікальне ім'я.

-   Порядок рядків в таблиці довільний.

Заголовок (схема) відношення — скінченна множина впорядкованих пар виду \<A,
T\>, де A називається іменем атрибута, а T означає ім'я деякого базового типу
або раніше визначеного домену. Всі імена атрибутів в заголовку мають бути
різними.

Кортеж, відповідний заголовку — множина впорядкованих триплетів \<A, T, v\>, по
одному такому триплету для кожного атрибута в заголовку. Третій елемент – v –
триплета \<A, T, v\> має бути дозволеним значенням типу даних або домена T.
Через те, що імена атрибутів унікальні, вказувати домен в кортежі зайве.

Тіло відношення — невпорядкована множина різних кортежів.

Реляційна таблиця має поля ID (ідентифікатор), тип даних, ключ. Зв’язки
створюються між первинним ключем (PK) и зовнішнім (FK). Зв'язок йде від
вторинного до первинного.

**Приклад**

![](media/3017ca65095f1270bb16d35bf6092c0a.png)

**Реляційна алгебра**

Реляційна алгебра — відгалуження логіки першого порядку, множина відношень
замкнених операторами. Оператори застосовуються до відношень, в результаті
застосування отримується нове відношення.

В математиці, алгебра відношень є алгебраїчною структурою щодо математичної
логіки та теорії множин.

Подібно до інших алгебр, деякі оператори є примітивними, а інші, будучи
визначені через примітивні, є похідними від них. В реляційній алгебрі Кодда
визначено такі шість примітивних операторів: вибірка, проекція, декартів
добуток, об'єднання та різниця і перейменування.

Шість операторів є фундаментальними в тому сенсі, що жоден із них не можна
відкинути без втрати потужності. Багато інших операторів було визначено
комбінацією цих шести. Серед найважливіших можна назвати: перетин множин,
ділення та природнє об'єднання. Насправді, ISBL дала підстави для заміни
декартового добутку природнім об'єднанням, окремим випадком якого є декартів
добуток.

**ЗАВДАННЯ**

1.  Вивчити реляційну модель даних, що вона описує, де використовується.

2.  Побудувати реляційну таблицю:

3.  Виходячи з діаграми бізнес об’єктів побудувати таблицю з відповідними
    назвами комірок.

4.  Відповідно до назви комірки назначити відповідний тип даних для кожної
    комірки.

5.  Назначити ключі в кожній таблиці, в яких потрібно створити зв’язки.

6.  Створити відношення між ключами.

**ПИТАННЯ ДЛЯ САМОСТІЙНОЇ ПЕРЕВІРКИ**

1.  Що таке реляційна модель даних.

2.  Структура реляційної моделі даних.

3.  Відношення в реляційній моделі.

4.  Призначення реляційних моделей в проектування БД.

5.  Призначення реляційної алгебри.

6.  Особливості реляційної алгебри.

7.  Розмітка реляційної таблиці.

8.  Нормальні форми в реляційній моделі даних.

**ПРОТОКОЛ**

Протокол має містити титульну сторінку, завдання, роздруківку змісту каталогу
проекту з відповідними коментарями та роздруківку файлів .project, .classpath,
build.xml з відповідними коментарями

**СПИСОК РЕКОМЕНДОВАНИХ ІНФОРМАЦІЙНИХ ДЖЕРЕЛ**

# Реалізація бази даних засобами MySQL 

**МЕТА**

Навчитися встановлювати та налаштовувати системи розробки баз даних MySQL та
Oracle SQL Developer.

**ДОВІДКА**

**Встановлення та налаштування серверу баз даних**

Сервер БД обслуговує базу даних і відповідає за цілісність і збереження даних, а
також забезпечує операції введення-виведення при доступі клієнта до інформації.

Архітектура клієнт-сервера складається з клієнтів і серверів. Основна ідея
полягає в тому, щоб розміщувати сервери на потужних машинах, а додаткам, що
використовують мовні компоненти СУБД, забезпечити доступ до них з менш потужних
машин-клієнтів за допомогою зовнішніх інтерфейсів.

Більшість СУБД використовують мову SQL (Structured Query Language - мова
структурованих запитів), так як вона зручна для опису логічних підмножин БД.

Призначення SQL:

-   Створення БД і таблиці з повним описом їх структури;

-   Виконання основних операцій маніпулювання даними (такі як вставка,
    модифікація і видалення даних з таблиць);

-   Виконання простих і складних запитів.

Одна з ключових особливостей мови SQL полягає в тому, що з її допомогою
формуються запити, що описують яку інформацію з бази даних необхідно отримати, а
шляхи вирішення цього завдання програма визначає сама.

**MySQL**

MySQL - вільна система управління базами даних (СКБД). MySQL є власністю
компанії Oracle Corporation, що отримала її разом з поглинанням Sun
Microsystems, що здійснює розробку і підтримку програми. Розповсюджується під
GNU General Public License або під власною комерційною ліцензією.

Гнучкість СУБД MySQL забезпечується підтримкою великої кількості типів таблиць:
користувачі можуть вибрати як таблиці типу MyISAM, що підтримують повнотекстовий
пошук, так і таблиці InnoDB, що підтримують транзакції на рівні окремих записів.
Більш того, СУБД MySQL поставляється із спеціальним типом таблиць EXAMPLE, що
демонструє принципи створення нових типів таблиць. Завдяки відкритій архітектурі
і GPL-ліцензуванню, в СУБД MySQL постійно з'являються нові типи таблиць.

MySQL портована на велику кількість платформ: AIX, BSDi, FreeBSD, HP-UX, Linux,
Mac OS X, NetBSD, OpenBSD, OS / 2 Warp, SGI IRIX, Solaris, SunOS, SCO
OpenServer, SCO UnixWare, Tru64, Windows 95, Windows 98, Windows NT, Windows
2000, Windows XP, Windows Server 2003, WinCE, Windows Vista і Windows 7.

MySQL має API для мов Delphi, C, C + +, Ейфель, Java, Лісп, Perl, PHP,
PureBasic, Python, Ruby, Smalltalk, Компонентний Паскаль і Tcl бібліотеки для
мов платформи. NET

**Oracle SQL Developer**

Oracle SQL Developer - інтегрована середа розробки на мовах SQL і PL / SQL,
орієнтована на застосування в середовищі Oracle Database. Корпорація Oracle
надає продукт безкоштовно. Сама середу написана на мові програмування Java,
працює на всіх платформах, де доступна середу виконання Java SE.

Для встановлення серверу потрібно завантажити файл інсталяції. Посилання на
файли:

MySQL:

-   [/](http://vk.com/away.php?to=http%3A%2F%2Fwww.mysql.ru%2Fdownload%2F)

-   <http://www.mysql.com/downloads/>

GUI:

-   <http://www.mysql.com/downloads/workbench/>

Oracle Developer Tool:

-   <http://www.oracle.com/technetwork/developer-tools/sql-developer/downloads/index.html>

**Приклад інсталяції**

Для встановлення MySQL:

1.  Завантажити з сайту [/](http://www.mysql.ru/download/) install-файл із
    розділу MySQL-5.1 /MySQL Community Server 5.1/ в залежності від параметрів
    системи.

2.  Для встановлення стандартного набору функцій в меню інсталяції обираємо
    пункт Typical-\>Next-\>Install

3.  Після інсталяції обираємо пункт *Configure the MySQL Server now-\>Finish*

4.  Для отримання стандартних налаштувань обираємо пункт Detailed
    configuration-\>Server Machine-\>Multifunctional Database

5.  Вказуємо адресу для зберігання налаштувань -\>Next-\>Decision Support

6.  Enable TCP\\IP Networking  
    

    ![C:\\Users\\Кристина\\Desktop\\2.JPG](media/d0d81f7368cea6ec7170580597a50d2b.jpg)

7.  Обираємо кодування Manual Selected Default Character Set  
    

    ![**C:\\Users\\Кристина\\Desktop\\3.JPG**](media/f918ff9b95ddef7237006b82fd71f11a.jpg)

8.  Next-\>Install as Windows Server-\> Next

9.  Обираємо параметр Modify Security Service, та вводимо свій пароль
    доступу-\>Next-\>Execute-\>Finish  
    

    ![**C:\\Users\\Кристина\\Desktop\\4.JPG**](media/5f2524b35dccdbb582e49119928aa15a.jpg)

10. Запускаємо MySQL Command Line Client

11. Вводимо свій пароль.  
    

    ![C:\\Users\\Кристина\\Desktop\\Снимок1.JPG](media/0290fdc4870f37736a44274034b949e6.jpg)

Для встановлення GUI:

1.  Завантажити з сайту <http://www.mysql.com/downloads/workbench/> install-файл
    в залежності від параметрів системи (Примітка. Для користувачів Windows
    система має бути Windows XP SP3 або вище).

2.  Для встановлення стандартного набору функцій в меню Setup Type обираємо
    пункт Complete -\> Next-\>Install-\>Finish.

![workb.png](media/edab5006611fd66fd220b8bbb251bb2d.png)

Для встановлення Oracle XE:

1.  Завантажити з сайту
    [html](http://www.oracle.com/technetwork/products/express-edition/downloads/index.html)
    архів з програмою інсталяції (Примітка. Для того, щоб мати змогу
    завантажити, потрібно зареєструватись на сайті Oracle).

2.  Розпакувати архів. Запустити програму інсталяції Setup.exe.

3.  Провести стандартну процедуру встановлення (вибір каталогу, де буде
    встановлена програма, підтвердження лінцензійної домовленості,тощо)

4.  У вікні Specify Database Passwords у вказане поле ввести свій унікальний
    пароль для бази даних.

Для встановлення Oracle Developer Tool:

1.  Завантажити з сайту
    [html](http://www.oracle.com/technetwork/developer-tools/sql-developer/downloads/index.html)
    архів з програмою (Примітка. Для того, щоб мати змогу завантажити, потрібно
    зареєструватись на сайті Oracle). Програма працює за умови,що на комп’ютері
    встановлена JDK 1.6.0_11 або вище. Завантажити JDK можна за цією адресою:
    <http://www.oracle.com/technetwork/java/javase/downloads/index.html>

2.  Розпакувати архів. Відкрити папку sqldeveloper з архіву і запустити файл
    sqldeveloper.exe. У вікні,що відкриється потрібно вказати повний шлях, за
    яким знаходиться виконавчий файл java.exe. Він знаходиться в папці, в якій
    встановлено Java (наприклад: C:\\Program Files\\Java\\jdk
    1.6.0_32\\bin\\java.exe).

**Мова структурованих запитів SQL.**

SQL (англ. Structured query language — мова структурованих запитів) —
декларативна мова програмування для взаємодії користувача з базами даних, що
застосовується для формування запитів, оновлення і керування реляційними БД,
створення схеми бази даних і її модифікація, система контролю за доступом до
бази даних. Сам по собі SQL не є ні системою керування базами даних, ні окремим
програмним продуктом. Не будучи мовою програмування в тому розумінні, як C або
Pascal, SQL може формувати інтерактивні запити або, будучи вбудованою в
прикладні програми, виступати в якості інструкцій для керування даними. Стандарт
SQL, крім того, вміщує функції для визначення зміни, перевірки і захисту даних.

    SQL — це діалогова мова програмування для здійснення запиту і внесення змін до
бази даних, а також управління базами даних. Багато баз даних підтримує SQL з
розширеннями до стандартної мови. Ядро SQL формує командна мова, яка дозволяє
здійснювати пошук, вставку, обновлення, і вилучення даних, використовуючи
систему управління і адміністративні функції. SQL також включає CLI (Call Level
Interface) для доступу і управління базами даних дистанційно.

**DDL **

Data Definition Language (мова опису даних). За допомогою цієї мови визначають
дані, вказуючи тип даних, структури уявлення. Взагалі то це частина мови SQL,
але тільки одна. Це ті оператори, які пов'язані з командами створення, наприклад
CREATE TABLE. Результатом виконання цих операцій заноситися в системний каталог,
в якому зберігаються відомості про таблиці.

    Функції мов DDL визначаються першим словом у реченні (часто званому запитом),
яке майже завжди є дієсловом. У випадку з SQL ці дієслова - «Create»
(«створити»), «Alter» («змінити»), «Drop» («видалити»). Це перетворює природу
мови в ряд обов'язкових тверджень (команд) до бази даних.

**Create table**

    Оператор create table створює таблицю з заданим ім'ям у поточній базі даних.
Якщо немає активної поточної бази даних або зазначена таблиця вже існує, то
виникає помилка виконання команди.

    У версії MySQL 3.22 і більш пізніх ім'я таблиці може бути вказано як
«db_name.tbl_name». Ця форма запису працює незалежно від того, чи є зазначена
база даних поточною. У версії MySQL 3.23 при створенні таблиці можна
використовувати ключове слово temporary. Тимчасова таблиця автоматично
видаляється після завершення з'єднання, а її ім'я дійсно тільки протягом даного
з'єднання. Це означає, що в двох різних з'єднаннях можуть використовуватися
тимчасові таблиці з однаковими іменами без конфлікту один з одним або з існуючою
таблицею з тим же ім'ям (існуюча таблиця прихована, поки не видалена тимчасова
таблиця).

    У версії MySQL 3.23 і більш пізніх можна використовувати ключові слова IF NOT
EXISTS для того, щоб не виникала помилка, якщо зазначена таблиця вже існує. Слід
враховувати, що при цьому не перевіряється ідентичність структур цих
таблиць.Кожна таблиця tbl_name представлена певними файлами в директорії бази
даних.

**Drop table**

DROP TABLE [IF EXISTS] tbl_name [, tbl_name, ...] [RESTRICT \| CASCADE]

    Оператор Drop table видаляє одну чи кілька таблиць. Всі табличні дані і
визначення видаляються, так що будьте уважні при роботі з цією командою!

    У версії MySQL 3.22 і більш пізніх можна використовувати ключові слова IF
EXISTS, щоб попередити помилку, якщо зазначені таблиці не існують.

    Опції RESTRICT і CASCADE дозволяють спростити перенесення програми. В даний
момент вони не задіяні.

Примітка: DROP TABLE автоматично приймає поточну активну транзакцію.

**Alter table**

    Оператор Alter table забезпечує можливість змінювати структуру існуючої
таблиці.Наприклад, можна додавати або видаляти стовпці, створювати або знищувати
індекси або перейменовувати стовпці або саму таблицю. Можна також змінювати
коментар для таблиці і її тип. Якщо оператор ALTER TABLE використовується для
зміни визначення типу стовпця, але DESCRIBE tbl_name показує, що стовпець не
змінився, то, можливо, MySQL ігнорує дану модифікацію по одній з причин,
Наприклад, при спробі змінити стовпець VARCHAR на CHAR MySQL буде продовжувати
використовувати VARCHAR, якщо дана таблиця містить інші стовпці з змінною
довжиною.

    Оператор ALTER TABLE під час роботи створює тимчасову копію вихідної
таблиці.Необхідний зміна виконується на копії, потім вихідна таблиця
віддаляється, а нова перейменовується. Так робиться для того, щоб в нову таблицю
автоматично потрапляли всі оновлення крім невдалих. Під час виконання ALTER
TABLE вихідна таблиця доступна для читання іншими клієнтами. Операції поновлення
і записи в цій таблиці припиняються, поки не буде готова нова таблиця.

    Слід зазначити, що при використанні будь-якої іншої опції для ALTER TABLE крім
RENAME, MySQL завжди буде створювати тимчасову таблицю, навіть якщо дані, строго
кажучи, і не потребують копіюванні (наприклад, при зміні імені стовпця). Ми
плануємо виправити це в майбутньому, однак, оскільки ALTER TABLE виконується не
так часто, ми (розробники MySQL) не вважаємо це завдання першочергове. Для
таблиць MyISAM можна збільшити швидкість відтворення індексного частини (що є
найбільш повільною частиною в процесі відновлення таблиці) шляхом установки
змінної myisam_sort_buffer_size досить великого значення.

**Приклад**

![](media/3017ca65095f1270bb16d35bf6092c0a.png)

**Скрипт**

\-- MySQL Workbench Forward Engineering

SET \@OLD_UNIQUE_CHECKS=\@\@UNIQUE_CHECKS, UNIQUE_CHECKS=0;

SET \@OLD_FOREIGN_KEY_CHECKS=\@\@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;

SET \@OLD_SQL_MODE=\@\@SQL_MODE, SQL_MODE='TRADITIONAL,ALLOW_INVALID_DATES';

\-- -----------------------------------------------------

\-- Schema DataManagementSystem

\-- -----------------------------------------------------

DROP SCHEMA IF EXISTS \`DataManagementSystem\` ;

\-- -----------------------------------------------------

\-- Schema DataManagementSystem

\-- -----------------------------------------------------

CREATE SCHEMA IF NOT EXISTS \`DataManagementSystem\` DEFAULT CHARACTER SET utf8
;

USE \`DataManagementSystem\` ;

\-- -----------------------------------------------------

\-- Table \`DataManagementSystem\`.\`ObjectControl\`

\-- -----------------------------------------------------

DROP TABLE IF EXISTS \`DataManagementSystem\`.\`ObjectControl\` ;

CREATE TABLE IF NOT EXISTS \`DataManagementSystem\`.\`ObjectControl\` (

\`objectControlId\` INT NOT NULL AUTO_INCREMENT,

\`objectType\` VARCHAR(45) NULL,

PRIMARY KEY (\`objectControlId\`),

UNIQUE INDEX \`objectControlId_UNIQUE\` (\`objectControlId\` ASC))

ENGINE = InnoDB;

\-- -----------------------------------------------------

\-- Table \`DataManagementSystem\`.\`Metadata\`

\-- -----------------------------------------------------

DROP TABLE IF EXISTS \`DataManagementSystem\`.\`Metadata\` ;

CREATE TABLE IF NOT EXISTS \`DataManagementSystem\`.\`Metadata\` (

\`metadataId\` INT NOT NULL AUTO_INCREMENT,

\`Key\` VARCHAR(45) NULL,

\`Value\` VARCHAR(45) NULL,

\`objectControlId\` INT NOT NULL,

PRIMARY KEY (\`metadataId\`, \`objectControlId\`),

INDEX \`fk_Metadata_ObjectControl_idx\` (\`objectControlId\` ASC),

UNIQUE INDEX \`metadataId_UNIQUE\` (\`metadataId\` ASC),

CONSTRAINT \`fk_Metadata_ObjectControl\`

FOREIGN KEY (\`objectControlId\`)

REFERENCES \`DataManagementSystem\`.\`ObjectControl\` (\`objectControlId\`)

ON DELETE NO ACTION

ON UPDATE NO ACTION)

ENGINE = InnoDB;

\-- -----------------------------------------------------

\-- Table \`DataManagementSystem\`.\`DataPoints\`

\-- -----------------------------------------------------

DROP TABLE IF EXISTS \`DataManagementSystem\`.\`DataPoints\` ;

CREATE TABLE IF NOT EXISTS \`DataManagementSystem\`.\`DataPoints\` (

\`tableName\` VARCHAR(45) NOT NULL,

\`dataPointsId\` INT NOT NULL,

PRIMARY KEY (\`dataPointsId\`),

UNIQUE INDEX \`dataPointsId_UNIQUE\` (\`dataPointsId\` ASC),

UNIQUE INDEX \`tableName_UNIQUE\` (\`tableName\` ASC),

CONSTRAINT \`fk_DataPoints_ObjectControl1\`

FOREIGN KEY (\`dataPointsId\`)

REFERENCES \`DataManagementSystem\`.\`ObjectControl\` (\`objectControlId\`)

ON DELETE NO ACTION

ON UPDATE NO ACTION)

ENGINE = InnoDB;

\-- -----------------------------------------------------

\-- Table \`DataManagementSystem\`.\`Concept\`

\-- -----------------------------------------------------

DROP TABLE IF EXISTS \`DataManagementSystem\`.\`Concept\` ;

CREATE TABLE IF NOT EXISTS \`DataManagementSystem\`.\`Concept\` (

\`conceptId\` INT NOT NULL,

\`conceptName\` VARCHAR(45) NULL,

\`type\` VARCHAR(45) NULL,

\`validator\` VARCHAR(45) NULL,

\`tableName\` VARCHAR(45) NULL,

\`filter\` VARCHAR(45) NULL,

\`conceptParentId\` INT NULL,

PRIMARY KEY (\`conceptId\`),

INDEX \`fk_Concept_Concept1_idx\` (\`conceptParentId\` ASC),

UNIQUE INDEX \`conceptId_UNIQUE\` (\`conceptId\` ASC),

UNIQUE INDEX \`conceptName_UNIQUE\` (\`conceptName\` ASC),

CONSTRAINT \`fk_Concept_ObjectControl1\`

FOREIGN KEY (\`conceptId\`)

REFERENCES \`DataManagementSystem\`.\`ObjectControl\` (\`objectControlId\`)

ON DELETE NO ACTION

ON UPDATE NO ACTION,

CONSTRAINT \`fk_Concept_Concept1\`

FOREIGN KEY (\`conceptParentId\`)

REFERENCES \`DataManagementSystem\`.\`Concept\` (\`conceptId\`)

ON DELETE NO ACTION

ON UPDATE NO ACTION)

ENGINE = InnoDB;

\-- -----------------------------------------------------

\-- Table \`DataManagementSystem\`.\`Role\`

\-- -----------------------------------------------------

DROP TABLE IF EXISTS \`DataManagementSystem\`.\`Role\` ;

CREATE TABLE IF NOT EXISTS \`DataManagementSystem\`.\`Role\` (

\`roleId\` INT NOT NULL,

\`roleType\` VARCHAR(45) NULL,

PRIMARY KEY (\`roleId\`),

UNIQUE INDEX \`roleId_UNIQUE\` (\`roleId\` ASC))

ENGINE = InnoDB;

\-- -----------------------------------------------------

\-- Table \`DataManagementSystem\`.\`Association\`

\-- -----------------------------------------------------

DROP TABLE IF EXISTS \`DataManagementSystem\`.\`Association\` ;

CREATE TABLE IF NOT EXISTS \`DataManagementSystem\`.\`Association\` (

\`index\` INT NULL,

\`dataPointsId\` INT NOT NULL,

\`conceptId\` INT NOT NULL,

\`roleId\` INT NOT NULL,

PRIMARY KEY (\`dataPointsId\`, \`conceptId\`, \`roleId\`),

INDEX \`fk_Association_Concept1_idx\` (\`conceptId\` ASC),

INDEX \`fk_Association_Role1_idx\` (\`roleId\` ASC),

CONSTRAINT \`fk_Association_DataPoints1\`

FOREIGN KEY (\`dataPointsId\`)

REFERENCES \`DataManagementSystem\`.\`DataPoints\` (\`dataPointsId\`)

ON DELETE NO ACTION

ON UPDATE NO ACTION,

CONSTRAINT \`fk_Association_Concept1\`

FOREIGN KEY (\`conceptId\`)

REFERENCES \`DataManagementSystem\`.\`Concept\` (\`conceptId\`)

ON DELETE NO ACTION

ON UPDATE NO ACTION,

CONSTRAINT \`fk_Association_Role1\`

FOREIGN KEY (\`roleId\`)

REFERENCES \`DataManagementSystem\`.\`Role\` (\`roleId\`)

ON DELETE NO ACTION

ON UPDATE NO ACTION)

ENGINE = InnoDB;

**ПИТАННЯ ДЛЯ САМОСТІЙНОЇ ПЕРЕВІРКИ**

1) Дайте визначення SQL?

2) Чи є SQL мовою програмування?

3) Перелічите основні завдання й функції SQL

4) DDL дайте визначення й назвіть характерні риси

5) DML призначення й принципи

6) Які різновиди DML мови ви знаєте?

7) Які є об'єкти в БД?

8) Назвіть основні функції операторів Create, Drop й Alter

9) Приведіть приклад синтаксису операторів Create, Drop й Alter

**ПРОТОКОЛ**

Протокол має містити титульну сторінку,скріншоти завдання.

**СПИСОК РЕКОМЕНДОВАНИХ ІНФОРМАЦІЙНИХ ДЖЕРЕЛ:**

1.  MySQL. – <http://ru.wikipedia.org/wiki/MySQL>

2.  Oracle Developer Suit. –
    <http://en.wikipedia.org/wiki/Oracle_Developer_Suite>

3.  MySQL Official Site. – <http://www.mysql.com/>

4.  Oracle Official Site – <http://www.oracle.com/index.html>

5.  Сервер базы данных –
    [/Сервер_базы_данных](http://ru.wikipedia.org/wiki/Сервер_базы_данных)

6.  Oracle Database – http://ru.wikipedia.org/wiki/Oracle_Database

7.  Вікіпедія – SQL - [SQL](http://uk.wikipedia.org/wiki/SQL)

8.  Розуміння SQL (Understanding SQL) -
    <http://www.sql.ru/docs/sql/u_sql/index.shtml>

9.  Вікіпедія - База даних -
    <http://uk.wikipedia.org/wiki/%D0%91%D0%B0%D0%B7%D0%B0_%D0%B4%D0%B0%D0%BD%D0%B8%D1%85>

10. MySQL 5 Максим Кузніцов, Ігор Сімдянов, Видавництво: БХВ-Петербург, 2010,
    Сторінок: 1024

11. MySQL. Керівництво Адміністратора, Автор: Компанія MySQL AB Видавництво:
    Вільямс Сторінок: 624  
    

# Наповнення бази даних, реалізація запитів з використанням мови SQL

**МЕТА**

Отримання базових навичок з використання мови SQL. 

**ДОВІДКА**

**DML  **

Data Manipulation Language (мова управління (маніпулювання) даними). Це мова
керування даними, за допомогою якого можна витягувати і змінювати дані. Є два
різновиди цих мов:

    - Процедурні (процедурний)

    - Номери Процедурні (непроцедурного)

Різниця між ними не така як здається на перший погляд. Насправді процедурні мови
обробляють дані послідовно. Тобто запис за записом, а не процедурні оперують
відразу цілими наборами. І різниця звідси видно, що в процедурних мовах
вказується, як потрібно отримувати дані, а в не процедурних, що ми хочемо
отримати. Процес в не процедурній мові нас не хвилює, і він прихований від
розробника. Найбільш поширений не процедурна мова це SQL. І тут має стати
зрозуміло, що таке, коли ми вказуємо не шлях, а результат.

    Оператор SQL типу SELECT \* FROM TABLE говорить про результат, який хочемо. А в
даному випадку ми хочемо отримати всі записи і колонки з таблиці. Є ще один не
процедурний мова QBE.

**Мова вибірки даних **

Для вибірки даних з БД використовується запит SELECT. Він дозволяє робити
вибірку потрібних даних з таблиць і перетворювати до потрібного виду отримані
результати. У загальному випадку результатом реалізації запиту SELECT, є інша
таблиця, яку будемо називати таблицею результатів запиту (ТРЗ). До цієї нової
(робочої) таблиці може бути знову застосовано запит SELECT, і т.д., тобто такі
операції можуть бути вкладені одна в одну.

Таблиця "Persons":

| P_Id | LastName  | FirstName | Address      | City      |
|------|-----------|-----------|--------------|-----------|
| 1    | Hansen    | Ola       | Timoteivn 10 | Sandnes   |
| 2    | Svendson  | Tove      | Borgvn 23    | Sandnes   |
| 3    | Pettersen | Kari      | Storgt 20    | Stavanger |

Тепер ми хочемо вибрати зміст колонок під назвою "*LastName* " та "*FirstName*"
з таблиці вище.

Ми використаємо команду SELECT таким чином:

SELECT LastName,FirstName FROM Persons

В результаті отримаємо:

| LastName  | FirstName |
|-----------|-----------|
| Hansen    | Ola       |
| Svendson  | Tove      |
| Pettersen | Kari      |

Таблиця "Persons":

| P_Id | LastName  | FirstName | Address      | City      |
|------|-----------|-----------|--------------|-----------|
| 1    | Hansen    | Ola       | Timoteivn 10 | Sandnes   |
| 2    | Svendson  | Tove      | Borgvn 23    | Sandnes   |
| 3    | Pettersen | Kari      | Storgt 20    | Stavanger |
| 4    | Nilsen    | Johan     | Bakken 2     | Stavanger |
| 5    | Tjessem   | Jakob     |              |           |
|      |           |           |              |           |

Тепер ми хочемо оновити персону " TjessemJakob " в таблиці " Persons ".

Ми використовуємо такі команди SQL:

UPDATE Persons  
SET Address='Nissestien 67', City='Sandnes'  
WHERE LastName='Tjessem' AND FirstName='Jakob'

В результаті отримаємо:

| P_Id | LastName  | FirstName | Address       | City      |
|------|-----------|-----------|---------------|-----------|
| 1    | Hansen    | Ola       | Timoteivn 10  | Sandnes   |
| 2    | Svendson  | Tove      | Borgvn 23     | Sandnes   |
| 3    | Pettersen | Kari      | Storgt 20     | Stavanger |
| 4    | Nilsen    | Johan     | Bakken 2      | Stavanger |
| 5    | Tjessem   | Jakob     | Nissestien 67 | Sandnes   |

Таблиця "Persons":

| P_Id | LastName  | FirstName | Address      | City      |
|------|-----------|-----------|--------------|-----------|
| 1    | Hansen    | Ola       | Timoteivn 10 | Sandnes   |
| 2    | Svendson  | Tove      | Borgvn 23    | Sandnes   |
| 3    | Pettersen | Kari      | Storgt 20    | Stavanger |

Треба вставити новий рядок в таблицю "Persons".

INSERT INTO Persons  
VALUES (4,'Nilsen', 'Johan', 'Bakken 2', 'Stavanger')

В результаті отримаємо:

| P_Id | LastName  | FirstName | Address      | City      |
|------|-----------|-----------|--------------|-----------|
| 1    | Hansen    | Ola       | Timoteivn 10 | Sandnes   |
| 2    | Svendson  | Tove      | Borgvn 23    | Sandnes   |
| 3    | Pettersen | Kari      | Storgt 20    | Stavanger |
| 4    | Nilsen    | Johan     | Bakken 2     | Stavanger |

**ЗАВДАННЯ**

Вивчити основи мови структурних запитів SQL, недоліки та переваги мови, цілі
створення, стандарт-ревізії, сумісність мови.

Детально вивчити основні команди SQL та їх особливості. Вільно володіти такими
командами Select, Insert, Update.

Створити базу даних. Виконати зміну бази по варіанту.

**ПИТАННЯ ДЛЯ САМОСТІЙНОЇ ПЕРЕВІРКИ**

1.  Визначення SQL, призначення.

2.  Різниця між іншими мовами, недоліки та переваги

3.  Класифікація запитів в SQL

4.  Коротка характеристика команди SELECT, її особливості.

5.  Коротка характеристика команди UPDATE, її особливості.

6.  Коротка характеристика команди INSERT, її особливості.

**ПРОТОКОЛ**

Протокол має містити титульну сторінку,скріншоти завдання.

**СПИСОК РЕКОМЕНДОВАНИХ ІНФОРМАЦІЙНИХ ДЖЕРЕЛ:**

1.  <http://www.oszone.net/11675/Visio2010_DB_Modeling>

2.  <http://www.w3schools.com/sql/sql_insert.asp>

# Реалізація об’єктно-орієнтованої моделі предметної області з застосуванням мови Java

**МЕТА**

вивчення технології JDBC. Отримання базових навичок розробки клієнт-серверних
Java-додатків з використанням баз даних.

**ДОВІДКА**

JDBC — це прикладний програмний інтерфейс (далі API) Java для виконання
SQL-запитів. Він складається з великої кількості класів та інтерфейсів,
написаних на мові Java. JDBC надає стандартний API для розробників, які
використовують бази даних (далі БД). За допомогою JDBC можна писати програми на
мові Java, що використовують БД.

За допомогою JDBC легко посилати SQL-запити майже до всіх реляційних БД. Іншими
словами, використання JDBC API позбавляє від необхідності для кожної СУБД
(Informix, Oracle і т.д.) писати свій додаток. Достатньо написати одну єдину
програму, що використовує JDBC API, і ця програма зможе відсилати SQL-запити до
потрібної БД. Крім того, цей додаток може бути перенесено на різні платформи.

JDBC розширює і без того багату функціональність Java. Наприклад, можна
опублікувати в Інтернет веб-сторінку, яка містить аплет, пов'язаний з БД на
сервері. Ще один приклад: організація за допомогою JDBC може підключити всіх
співробітників до однієї БД, навіть якщо ми маємо справу з конгломератом
операційних систем на робочих станціях співробітників - Windows, Macintosh,
UNIX.

JDBC API дозволяє робити три речі:

-   встановлювати з’єднання з базою даних або отримувати доступ до будь-якого
    табличного сховища даних;

-   відправляти SQL запити;

-   оброблювати результати.

Приклад цих дій:

    **  **// Встановлення з’єднання

        Connection con = DriverManager.*getConnection*("jdbc:odbc:wombat",

                "login", "password");

        Statement stmt = con.createStatement();

        // Виконання запиту

        ResultSet rs = stmt.executeQuery("SELECT a, b, c FROM Table1");

        while (rs.next()) {

            int x = getInt("a"); // отримання результату

            String s = getString("b");

            float f = getFloat("c");

        }

JDBC API складається з двох основних наборів інтерфейсів: перший — JDBC API для
розробників програмного забезпечення, а другий JDBC driver API нижнього рівня
для розробників драйверів. Драйвери технології JDBC поділяються на чотири
категорії:

1. JDBC-ODBC + драйвер ODBC. Цей міст, використовує інтерфейс JDBC для доступу
до драйверів ODBC. Треба звернути увагу на те, що виконуваний код ODBC і, в
багатьох випадках, клієнтський код для СУБД мають знаходитись на кожній машині,
що використовує цей тип драйверів. Отже, цей тип драйверів найбільш типовий або
для корпоративних мереж, для яких конфігурація клієнтських місць не є проблемою,
або для web-додатка, написаного на Java (триланкова модель).

2. Частково Java драйвери. Цей тип драйверів перетворює виклики JDBC у виклики
клієнтського API для Oracle, Sybase, Informix, DB2 і т.д. Як і міст JDBC-ODBC,
цей тип драйверів вимагає, щоб на кожній клієнтської станції знаходився деякий
виконуваний (двійковий) не-java код.

3. Мережеві JDBC-драйвери на чистому Java. Ці драйвери транслюють програмні
виклики JDBC в незалежний від СУБД мережевий протокол, який потім транслюється в
протокол СУБД спеціальним проміжним сервером. Цей мережевий проміжний серверний
додаток з'єднує клієнтів на чистому Java з багатьма рызними БД. Цей спеціальний
мережевий протокол залежить від конкретного постачальника, тобто жорстко не
стандартизований. Це найбільш гнучкий і захищений в агресивному середовищі
Інтернету спосіб.

4. Драйвери "рідного" протоколу СУБД. Цей тип драйверів перетворює програмні
виклики в мережевий протокол, який використовується СУБД безпосередньо. Стає
можливим пряме підключення клієнтських машин до сервера БД. Цей метод знаходить
практичне застосування в Інтранет-середовищі. Так як багато таких протоколів
запатентовані (є власністю постачальників), то за розробку таких драйверів
відповідають постачальники СУБД.

Об'єкт Connection це з'єднання з БД. Сесія з'єднання включає в себе виконувані
SQL-запити і результати, які повертаються через з'єднання. Додаток може відкрити
одне або більше з’єднань з однією або декількома БД.

Стандартний спосіб отримання з'єднання — це виклик методу
DriverManager.getConnection(). Цьому методу передається рядок, що містить так
званий "URL". Клас DriverManager, що представляє собою рівень управління в JDBC,
намагається знайти драйвер, який може з'єднатися з БД за допомогою даного URL.
Клас DriverManager містить список зареєстрованих класів Driver, і при виклику
методу getConnection він перевіряє кожен драйвер і шукає серед них той, який
"вміє" підключатись до БД, зазначеної в URL. Метод connect() драйвера
використовує цей URL для встановлення з'єднання.

Користувач може пропустити цей управляючий рівень JDBC і викликати безпосередньо
методи класу Driver для відкриття з'єднання. Це може бути потрібним у тих
рідкісних випадках, коли два або більше драйвера можуть обслужити заданий URL,
але користувач хоче вибрати конкретний з них. Проте, набагато простіше покласти
цю роботу на клас DriverManager.

Наступний код демонструє відкриття з'єднання з БД, що знаходиться по URL "jdbc:
odbc: wombat", з ім'ям користувача "oboy" і паролем "12Java":

    String url = "jdbc: odbc: wombat";

    Connection con = DriverManager.*getConnection* (url, "oboy", "12Java");

Після того як встановлено з'єднання, воно використовується для виконання
SQL-запитів до БД. JDBC не обмежує синтаксис SQL-запитів, надаючи, таким чином,
більшу гнучкість у використанні специфічних для СУБД запитів або навіть взагалі
не-SQL запитів. Правда, користувач повинен бути впевнений, що СУБД "зрозуміє"
SQL-вирази, які їй відсилаються, та зможе обробляти наслідки такого
"нерозуміння". Наприклад, додаток, що намагається викликати збережену процедуру
в СУБД без підтримки збережених процедур, згенерує виняток. Всі драйвери,
помічені як JDBC COMPLIANTTM, реалізують можливості принаймні вступного рівня
ANSI SQL-2 (entry level). Це означає, що користувачі можуть покластися як
мінімум на цей стандартний рівень функціональності.

В JDBC є три класи для виконання SQL-запитів в БД і три методи в інтерфейсі
Connection, які створюють екземпляри цих класів. Ці класи і методи, які їх
створюють, перераховані нижче:

Statement — створюється методом createStatement(). Об'єкт Statement
використовується при простих SQL-запитах.

PreparedStatement — створюється методом prepareStatement(). Об'єкт
PreparedStatement використовується в SQL-запитах з одним або більше вхідними
параметрами (IN parameters). PreparedStatement містить групу методів, що
встановлюють значення вхідних параметрів, які відсилаються в БД при виконанні
запиту. Екземпляри класу PreparedStatement розширюють (успадковуються від)
Statement і, таким чином, включають методи Statement. Об'єкт PreparedStatement
потенційно може бути більш ефективним, ніж Statement, так як він прекомпілюється
і зберігається для майбутнього використання.

CallableStatement — створюється методом prepareCall(). Об'єкти CallableStatement
використовуються для виконання так званих збережених процедур - іменованих груп
SQL-запитів, на зразок виклику підпрограми. Об'єкт CallableStatement успадковує
методи обробки вхідних (IN) параметрів з PreparedStatement, а також додає методи
для обробки вихідних (OUT) і вхідних-вихідних (INOUT) параметрів.

Нижченаведений список дає уявлення про те, який саме з методів об'єкта
Connection краще використовувати для створення різних SQL-запитів:

-   Метод createStatement() використовується для простих SQL-виразів (без
    параметрів).

    -   Метод prepareStatement() використовується для SQL-виразів з одним або
        більше вхідним (IN-) параметром простих SQL-виразів, які виконуються
        часто.

    -   Метод prepareCall() використовується для виклику збереженої процедури

Транзакція складається з одного або більше виразів, які після виконання або всі
фіксуються (commit), або всі відкатуються назад (rollback). При виклику методу
commit() або rollback() поточна транзацкія закінчується і починається інша.

Кожне нове з'єднання за замовчуванням знаходиться в режимі автофіксації
(auto-commit), що означає автоматичну фіксацію (commit) транзакції після кожного
запиту. У цьому випадку транзакція складається з одного запиту. Якщо auto-commit
заборонений, транзакція не закінчується аж до явного виклику commit або
rollback, включаючи, таким чином, всі вирази, виконані з моменту останнього
виклику commit або rollback. В цьому випадку всі SQL-запити в транзакції
фіксуються або відкатуються групою.

Метод фіксації commit() робить остаточними всі зміни в БД, зроблені SQL-виразом,
і знімає також усі блокування, встановлені транзакцією. Метод rollback()
проігнорує, "відбракує" ці зміни.

Іноді користувачеві потрібно, щоб будь-яка зміна не вступила в силу до тих пір,
поки не вступить в силу попередня зміна. Цього можна досягти забороною
auto-commit і угрупованням обох запитів в одну транзакцію. Якщо обидві зміни
відбулися успішно, то викликається метод commit(), який переносить ефект від цих
змін до БД; якщо один або обидва запити не пройшли, то викликається метод
rollback(), який повертає колишній стан БД.

Більшість JDBC-драйверів підтримують транзакції. Насправді драйвер, відповідний
специфікації JDBC, зобов'язаний підтримувати їх. Інтерфейс DatabaseMetaData
надає інформацію про рівні ізольованості транзакцій, які підтримуються даної
СУБД.

Клас DriverManager є рівнем управління в JDBC і знаходиться між користувачем і
драйверами. Він відстежує всі доступні драйвери та дповідає за встановлення
з'єднань між БД та відповідним драйвером. До того ж, клас DriverManager
піклується про такі речі, як максимальний час логіна до БД і виведення
налагоджувальної інформації в журнал.

Для простих додатків єдиний корисний метод в цьому класі - це
DriverManager.getConnection(). Як можна здогадатися по його імені, він
встановлює з'єднання з БД. JDBC дозволяє користувачеві викликати також наступні
методи DriverManager: getDriver(), getDrivers() і registerDriver(), і метод
connect() інтерфейсу Driver, але в більшості випадків краще покласти подробиці
встановлення з'єднання на клас DriverManager.

Об'єкт Statement використовується для виконання SQL-запитів до БД. Існує три
типи об'єктів Statement. Всі три служать як би конейнерамі для виконання
SQL-виразів через дане з'єднання: Statement, PreparedStatement, який
наслідується від Statement, і CallableStatement, який наслідується від
PreparedStatement. Вони спеціалізуються на різних типах запитів: Statement
використовується для виконання простих SQL-запитів без параметрів;
PreparedStatement використовується для виконання прекомпільованих SQL-запитів з
або без вхідних (IN) параметрів; CallableStatement використовується для викликів
збережених процедур.

Інтерфейс Statement надає базові методи для виконання запитів і отримання
результатів. Інтерфейс PreparedStatement додає методи управління вхідними (IN)
параметрами; CallableStatement додає методи для маніпуляції вихідними (OUT)
параметрами.

ResultSet містить всі рядки, що задовольняють умовам в SQL-виразі і надає доступ
до даних в цих рядках за допомогою набору get-методів, які організовують доступ
до колонок поточного рядка. Метод ResultSet.next() використовується для
переміщення до наступного рядка ResultSet, роблячи його поточним.

Набір даних результату (result set) є таблицею із заголовками колонок і
відповідних значень, повернутих запитом. Наприклад, якщо ми маємо запит SELECT
a, b, c FROM Table1, то набір результату буде в наступній формі:

      a     b      c

--------  ---------  --------

12345   Cupertino  CA

83472   Redmond   WA

83492   Boston    MA

Інтерфейс PreparedStatement наслідується від Statement і відрізняється від
останнього наступним:

Екземпляри PreparedStatement "пам'ятають" скомпільовані SQL-вирази. Саме тому
вони називаються "prepared" ("підготовлені").

SQL-вирази в PreparedStatement можуть мати один або більше вхідних (IN)
параметр. Вхідний параметр - це параметр, значення якого не вказується при
створенні SQL-виразу. Замість нього в виразі на місці кожного вхідного параметра
ставиться знак ("?"). Значення кожного знаку питання встановлюється методами
setXXX перед виконанням запиту.

Оскільки об'єкти PreparedStatement прекомпільовані, виконання цих запитів може
відбуватися дещо швидше, ніж в об'єктах Statement. В результаті SQL-вирази, які
виконуються часто, з метою поліпшення продуктивності створюють у вигляді
об'єктів PreparedStatement.

Залишаючись підкласом класу Statement, клас PreparedStatement успадковує всі
функції від Statement. Також він додає методи установки вхідних параметрів. Крім
того, три методу - execute(), executeQuery() і executeUpdate() - модифіковані
таким чином, що не мають аргументів. Старі методи класу Statement (які беруть
SQL-вирази як одного аргументу) не повинні використовуватися в об'єкті
PreparedStatement.

**ПРИКЛАД **

SQL-запити створення таблиці, вставки даних і виводу створеної таблиці.

CREATE TABLE books (id INT, name VARCHAR(100), price INT);

INSERT INTO books VALUES ('1', 'vocabulary', '70');

INSERT INTO books VALUES ('2', 'novel', '40');

INSERT INTO books VALUES ('3', 'newspaper', '5');

INSERT INTO books VALUES ('4', 'poem', '25');

SELECT \* FROM books;

Приклад вихідного коду на мові Java, який підключається до локальної бази даних
MySQL і виконує описані вище запити засобами JDBC.

**import** java.sql.Connection;

**import** java.sql.DriverManager;

**import** java.sql.ResultSet;

**import** java.sql.SQLException;

**import** java.sql.Statement;

**public class** Main {

    **public static void** main(String[] args) **throws** SQLException {

        Connection conn = DriverManager.*getConnection*(

                "jdbc:mysql://localhost:3306/test", "root", "password");

        **if** (conn == **null**) {

            System.*out*.println("No connection!");

            System.*exit*(0);

        }

        Statement stmt = conn.createStatement();

        stmt.executeUpdate("CREATE TABLE books (id INT, name VARCHAR(100), price
INT);");

        stmt.executeUpdate("INSERT INTO books VALUES ('1', 'vocabulary', '70');");

        stmt.executeUpdate("INSERT INTO books VALUES ('2', 'novel', '40');");

        stmt.executeUpdate("INSERT INTO books VALUES ('3', 'newspaper', '5');");

        stmt.executeUpdate("INSERT INTO books VALUES ('4', 'poem', '25');");

        ResultSet rs = stmt.executeQuery("SELECT \* FROM books;");

        **while** (rs.next()) {

            System.*out*.println(rs.getString("id") + "\\t" + rs.getString("name")

                    + "\\t" + rs.getString("price"));

        }

        stmt.close();

    }

}

Ті ж дії, виконані за допомогою класу PreparedStatement:

**import** java.sql.Connection;

**import** java.sql.DriverManager;

**import** java.sql.PreparedStatement;

**import** java.sql.ResultSet;

**import** java.sql.SQLException;

**import** java.sql.Statement;

**public class** Main {

    **public static void** main(String[] args) **throws** SQLException {

        Connection conn = DriverManager.*getConnection*(

          "jdbc:mysql://localhost:3306/test",

          "root", "password");

**if** (conn == **null**) {

System.*out*.println("No connection!");

System.*exit*(0);

}

Statement stmt = conn.createStatement();

stmt.executeUpdate("CREATE TABLE books (id INT, name VARCHAR(100), price
INT);");

String insertString = "INSERT INTO books VALUES (?, ?, ?);";

PreparedStatement prepStmt = conn.prepareStatement(insertString);

prepStmt.setInt(1, 1);

prepStmt.setString(2, "vocabulary");

prepStmt.setInt(3, 70);

prepStmt.executeUpdate();

prepStmt.setInt(1, 2);

prepStmt.setString(2, "novel");

prepStmt.setInt(3, 40);

prepStmt.executeUpdate();

prepStmt.setInt(1, 3);

prepStmt.setString(2, "newpaper");

prepStmt.setInt(3, 5);

prepStmt.executeUpdate();

prepStmt.setInt(1, 4);

prepStmt.setString(2, "poem");

prepStmt.setInt(3, 25);

prepStmt.executeUpdate();

ResultSet rs = stmt.executeQuery("SELECT \* FROM books;");

**while** (rs.next()) {

System.*out*.println(rs.getString("id") + "\\t"

        + rs.getString("name") + "\\t" + rs.getString("price"));

}

stmt.close();

    }

}

**ЗАВДАННЯ**

1.  Встановити будь-який SQL-сервер (MySQL, Microsoft SQL Server, PostgreSQL
    тощо). Перевірити його роботу.

2.  За необхідності скачати файл-конектор для встановленого сервера, додати його
    шлях до проекту (для середовища Eclipse: Project – Properties – Java Build
    Path – Libraries – Add External JARs...).

3.  Спланувати базу даних, котра представляє набір об'єктів предметної області
    по варіанту (не менше 4 таблиць, в кожній не менше 3 колонок). Накреслити
    схему цієї бази даних.

4.  Розробити SQL-скрипт для створення розробленої бази даних, створення
    необхідних таблиць, заповнення рядків. Перевірити його правильність за
    допомогою інструментів СУБД (наприклад, через командний рядок).

5.  Розробити програму на мові Java з використанням JDBC, котра виконує ті ж
    дії, що й розроблений раніше SQL-скрипт. При цьому дещо змінити назву бази
    даних.

6.  За допомогою командного рядка або інших засобів СУБД порівняти наповнення
    створених двома описаними способами баз даних.

**ПИТАННЯ ДЛЯ САМОСТІЙНОЇ ПЕРЕВІРКИ**

1. Призначення інтерфейсу JDBC.

2. Що дозволяє робити JDBC API?

3. Два основні набори інтерфейсів JDBC API.

4. Чотири категорії драйверів JDBC API.

5. Призначення і синтаксис JDBC-URL.

6. Транзакція. Два основні методи, пов’язані з транзакцією.

7. Основний метод класу DriverManager та його призначення.

8. Етапи процедури відкриття з’єднання.

9. В яких випадках треба використовувати Statement, PrepearedStatement,
CallableStatement?

10. Різниця між Statement і PrepearedStatement.

11. Призначення ResultSet.

12. Що представляє із себе набір даних результату в ResultSet?

**ПРОТОКОЛ **

Протокол має містити титульну сторінку (з номером залікової книжки), завдання з
описом предметної області, розроблений програмний код та згенеровану
документацію в форматі JavaDoc.

**СПИСОК РЕКОМЕНДОВАНИХ ІНФОРМАЦІЙНИХ ДЖЕРЕЛ:**

1.  JDBC Overview - http://www.oracle.com/technetwork/java/overview-141217.html

2.  Lesson: JDBC Basics -
    http://docs.oracle.com/javase/tutorial/jdbc/basics/index.html

3.  Introduction to JDBC -
    http://infolab.stanford.edu/\~ullman/fcdb/oracle/or-jdbc.html

4.  Руководство по JDBC -
    http://www.javaportal.ru/java/tutorial/tutorialJDBC/index.html

5.  SQL Задачи и решения - http://www.sql-tutorial.ru/ru/content.html

6.  SQL Tutorial -  http://www.w3schools.com/sql/default.asp

# Реалізація об’єктно-реляційного відображення з застосуванням мови Java

**МЕТА  **

Отримання навичок зі створення DAO-інфраструктури для доступу до MySQL баз
даних, з використанням JDBC.

**ДОВІДКА**

DAO - об'єкт що надає абстрактний інтерфейс до деяких видів баз даних чи
механізмів персистентності реалізуючи певні операції без розкриття деталей бази
даних. Він надає відображення від програмних викликів до рівня персистентності.
Така ізоляція розділює запити до даних в термінах предметної області та їх
реалізацію засобами СКБД.

Персистентність - здатність стану існувати довше, ніж процес, що створив його.
Без цієї можливості, стан може існувати лише в оперативній пам'яті і
втрачається, коли оперативна пам'ять вимикається, наприклад, при вимкненні
комп'ютера.

**Налаштування бази даних**

mysql\> create database testdb;

Query OK, 1 row affected (0.02 sec)

mysql\> create user 'tuser'\@'localhost' identified by 'pswd';

Query OK, 0 rows affected (0.26 sec)

mysql\> grant all on testdb.\* to tuser\@localhost;

Query OK, 0 rows affected (0.06 sec)

mysql\> use testdb

Database changed

mysql\> create table employees (id INT NOT NULL AUTO_INCREMENT, name CHAR(100),
birdth DATE, office INT, PRIMARY KEY (id));

Query OK, 0 rows affected (0.17 sec)

mysql\> create table offices (id INT NOT NULL AUTO_INCREMENT, address CHAR(100),
city CHAR(30), PRIMARY KEY (id));Query OK, 0 rows affected (0.18 sec)

Стан бази даних після запуску програми

mysql\> select \* from employees;

\+----+-----------+------------+--------+

\| id \| name   \| birdth   \| office \|

\+----+-----------+------------+--------+

\| 1 \| Peter G. \| 2012-05-20 \|   1 \|

\| 2 \| George H. \| 2012-05-20 \|   2 \|

\| 3 \| John A.  \| 2012-05-20 \|   1 \|

\| 4 \| Adams B. \| 2012-05-20 \|   2 \|

\+----+-----------+------------+--------+

4 rows in set (0.00 sec)

mysql\> select \* from offices;

\+----+----------------------+------+

\| id \| address       \| city \|

\+----+----------------------+------+

\| 1 \| Polytechnic street 1 \| Kyiv \|

\| 2 \| Polytechnic street 5 \| Kyiv \|

\+----+----------------------+------+

2 rows in set (0.00 sec)

**Реалізації DAO**

**  **Створюються класи, які відповідають моделі бізнес-об’єктів.

**package** ua.kpi.lab111.LabDAO.entity;

**import** java.util.Date;

/\*\*

\* bean-объект сотрудника

\*/

**public class** Employee {

    **private int** id;

    **private** String name;

    **private** Date birdthday;

    **private** Office office;

    **public int** getId() {

        **return** id;

    }

    **public void** setId(**int** id) {

        **this**.id = id;

    }

    **public** String getName() {

        **return** name;

    }

    **public void** setName(String name) {

        **this**.name = name;

    }

    **public** Date getBirdthday() {

        **return** birdthday;

    }

    **public void** setBirdthday(Date birdthday) {

        **this**.birdthday = birdthday;

    }

    **public** Office getOffice() {

        **return** office;

    }

    **public void** setOffice(Office office) {

        **this**.office = office;

    }

}

**package** ua.kpi.lab111.LabDAO.entity;

/\*\*

\* bean-объект офиса

\*/

**public class** Office {

    **private int** id;

    **private** String city;

    **private** String address;

    **public int** getId() {

        **return** id;

    }

    **public void** setId(**int** id) {

        **this**.id = id;

    }

    **public** String getCity() {

        **return** city;

    }

    **public void** setCity(String city) {

        **this**.city = city;

    }

    **public** String getAddress() {

        **return** address;

    }

    **public void** setAddress(String address) {

        **this**.address = address;

    }

}

Створюється фасад - клас, через який клієнтський код працює з базою даних. Він
реалізує методі CRUD для всіх таблиць у базі.

**package** ua.kpi.lab111.LabDAO;

**import** java.io.Serializable;

**import** java.sql.\*;

**import** java.util.ArrayList;

**import** java.util.Enumeration;

**import** java.util.Hashtable;

**import** java.util.List;

**import** ua.kpi.lab111.LabDAO.entity.Employee;

//Basic CRUD operations

/\*\*

\* Абстрактный класс, который реализует базовые CRUD-операции

\*

\* **\@param** \<T\> bean-класс

\*/

**public abstract class** DAO\<T\> **implements** Serializable {

    /\*\*

     \* JDBC соединение с базой данных

     \*/

    **private static** Connection *conn*;

    /\*\*

     \* bean-класс сущностей

     \*/

    **private** Class\<T\> entityClass;

    /\*\*

     \* Соединение с базой данных для всех DAO\<T\> наследников

     \* **\@return** объект соединения

     \*/

    **protected static** Connection getConn() {

        **return** *conn*;

    }

    /\*\*

     \* Установка соединения для всех DAO\<T\> наследников

     \* **\@param** conn объект соединения

     \*/

    **protected static void** setConn(Connection conn) {

        DAO.*conn* = conn;

    }

    /\*\*

     \* Конструктор, устанавливающий соединение при первом вызове

     \* **\@param** cls bean-класс

     \*/

    **protected** DAO(Class\<T\> cls) {

        entityClass = cls;

        **if** (*getConn*() == **null**) {

            **try** {

                Class.*forName*("com.mysql.jdbc.Driver");

                *setConn*(DriverManager.*getConnection*(

                        "jdbc:mysql://localhost/testdb", "tuser", "pswd"));

            } **catch** (SQLException e) {

                e.printStackTrace();

            } **catch** (ClassNotFoundException e) {

                e.printStackTrace();

            }

        }

    }

    /\*\*

     \* Операция создания новой строки в таблице

     \* **\@return** bean-объект

     \*/

    **public** T create() {

        T obj = **null**;

        **try** {

            obj = entityClass.newInstance();

        } **catch** (InstantiationException e) {

            e.printStackTrace();

        } **catch** (IllegalAccessException e) {

            e.printStackTrace();

        }

        Hashtable\<String,String\> t = makeKeyValues(obj);

        String cols = "";

        String data = "";

        **for** (Enumeration\<String\> e = t.keys(); e.hasMoreElements();) {

            String key = e.nextElement();

            cols += key + (e.hasMoreElements()?",":"");

            data += (String) t.get(key) + (e.hasMoreElements()?",":"");

        }

        PreparedStatement st;

        **try** {

            st = *getConn*().prepareStatement(

                    "INSERT INTO "+getTableName()+" ("+cols+") VALUES ("+data+");",
Statement.**RETURN_GENERATED_KEYS**);

            st.executeUpdate();

            ResultSet keys = st.getGeneratedKeys();

            keys.next();

            setObjectId(obj, keys.getInt(1));

        } **catch** (SQLException e) {

            e.printStackTrace();

        }

        **return** obj;

    }

    /\*\*

     \* Поиск по базе, используя переданное запрос

     \* **\@param** st запрос в базу

     \* **\@return** список результатов поиска

     \*/

    **public** ResultSet read(PreparedStatement st) {

        **try** {

            **return** st.executeQuery();

        } **catch** (SQLException e) {

            e.printStackTrace();

        }

        **return null**;

    }

    /\*\*

     \* Получение имени таблицы

     \* **\@return** название таблицы в базе

     \*/

    **protected abstract** String getTableName();

    /\*\*

     \* Получить ID из bean-объекта

     \* **\@param** object объект

     \* **\@return** id

     \*/

    **protected abstract int** getObjectId(T object);

    /\*\*

     \* Установить ID для bean-объекта

     \* **\@param** object объект

     \* **\@param** id id

     \*/

    **protected abstract void** setObjectId(T object, **int** id);

    /\*\*

     \* Заполнить bean-объект данными из результатов выполнения запроса

     \* **\@param** obj заполняемый объект

     \* **\@param** set множество результатов поиска, в данный

     \* момент указывающее на текущий объект

     \* **\@throws** SQLException

     \*/

    **protected abstract void** fillObjectFields(T obj, ResultSet set) **throws**
SQLException;

    /\*\*

     \* Создать Hashtable с данными из объекта

     \* **\@param** object объект

     \* **\@return** таблица с данными

     \*/

    **protected abstract** Hashtable\<String,String\> makeKeyValues(T object);

    /\*\*

     \* Поиск объекта в таблице по его id

     \* **\@param** id id

     \* **\@return** bean-объект

     \*/

    **public** T getById(**int** id) {

        T obj = **null**;

        **try** {

            PreparedStatement st = *getConn*().prepareStatement(

                "SELECT \* FROM ? WHERE id = ?;");

            st.setString(1, getTableName());

            st.setInt(2, id);

            ResultSet set = read(st);

            **if** (set.next()) {

                obj = entityClass.newInstance();

                fillObjectFields(obj, set);

            }

        } **catch** (SQLException e) {

            e.printStackTrace();

        } **catch** (InstantiationException e) {

            e.printStackTrace();

        } **catch** (IllegalAccessException e) {

            e.printStackTrace();

        }

        **return** obj;

    }

    /\*\*

     \* Обновить строку в таблице

     \* **\@param** object объект

     \*/

    **public void** update(T object) {

        PreparedStatement st;

        **try** {

            Hashtable\<String,String\> t = makeKeyValues(object);

            String query = "";

            **for** (Enumeration\<String\> e = t.keys(); e.hasMoreElements();) {

                String key = e.nextElement();

                String str = (String) t.get(key);

                query += key + "= '" + str +"'" + (e.hasMoreElements()?",":"");

            }

            String sql = "UPDATE "+getTableName()+" SET "+query+" WHERE id =
"+getObjectId(object)+";";

            st = *getConn*().prepareStatement(sql);

            st.execute();

        } **catch** (SQLException e) {

            e.printStackTrace();

        }

    }

    /\*\*

     \* Удалить элемент из таблицы

     \* **\@param** object удаляемый объект

     \*/

    **public void** remove(T object) {

        PreparedStatement st;

        **try** {

            st = *getConn*().prepareStatement(

                    "DELETE FROM "+getTableName()+" WHERE id = ?;");

            st.setInt(1, getObjectId(object));

            st.execute();

        } **catch** (SQLException e) {

            e.printStackTrace();

        }

    }

}

Створюється базовий абстрактний клас з узагальненим параметром, який забеспечує
з’єднання та базові абстрактні операції CRUD. Від нього наслідується по одному
класу для кожної таблиці, підставляючи в параметр bean-клас. У кожному
успадкованому класі реалізується CRUD в залежності від потреб таблиці.

**package** ua.kpi.lab111.LabDAO;

**import** java.sql.PreparedStatement;

**import** java.sql.ResultSet;

**import** java.sql.SQLException;

**import** java.text.SimpleDateFormat;

**import** java.util.ArrayList;

**import** java.util.Date;

**import** java.util.Enumeration;

**import** java.util.Hashtable;

**import** java.util.List;

**import** ua.kpi.lab111.LabDAO.entity.Employee;

/\*\*

\* DAO-объект для работы с таблицей сотрудников, синглтон

\*/

**public class** DAOEmployee **extends** DAO\<Employee\> {

    /\*\*

     \* Объект синглтона

     \*/

    **private static** DAOEmployee *instance*;

    /\*\*

     \* Получение объекта синглтона

     \* **\@return** синглтон

     \*/

    **public static synchronized** DAOEmployee getInstance() {

        **if** (*instance* == **null**) {

            *instance* = **new** DAOEmployee(Employee.**class**);

        }

        **return** *instance*;

    }

    /\*\*

     \* Унаследованый конструктор

     \* **\@param** cls класс bean-объекта

     \*/

    **protected** DAOEmployee(Class\<Employee\> cls) {

        **super**(cls);

    }

    /\*\*

     \* Поиск сотрудника по имени

     \* **\@param** name имя сотрудника

     \* **\@return** список результатов поиска

     \*/

    **public** List\<Employee\> getByName(String name) {

        PreparedStatement st;

        ArrayList\<Employee\> list = **new** ArrayList\<Employee\>();

        **try** {

            st = *getConn*().prepareStatement(

                    "SELECT \* FROM "+getTableName()+" WHERE name = ?;");

            st.setString(1, name);

            ResultSet set = read(st);

            **while** (set.next()) {

                Employee emp = **new** Employee();

                list.add(emp);

                fillObjectFields(emp, set);

            }

        } **catch** (SQLException e) {

            e.printStackTrace();

        }

        **return** list;

    }

    \@Override

    **protected void** fillObjectFields(Employee obj, ResultSet set) **throws**
SQLException {

        obj.setId(set.getInt(1));

        obj.setName(set.getString(2));

        obj.setBirdthday(set.getDate(3));

        **if** (set.getInt(4) != -1) {

            obj.setOffice(DAOOffice.*getInstance*().getById(set.getInt(4)));

        } **else** {

            obj.setOffice(**null**);

        }

    }

    \@Override

    **protected** String getTableName() {

        **return** "employees";

    }

    \@Override

    **protected int** getObjectId(Employee object) {

        **return** object.getId();

    }

    \@Override

    **protected void** setObjectId(Employee object, **int** id) {

        object.setId(id);

    }

    \@Override

    **protected** Hashtable\<String,String\> makeKeyValues(Employee object) {

        SimpleDateFormat format =

          **new** SimpleDateFormat("yyyyMMdd");

        Hashtable\<String,String\> table = **new** Hashtable\<String,String\>();

        table.put("name", (object.getName()==**null**)?"NULL":object.getName());

        table.put("birdth", format.format((object.getBirdthday()==**null**)?**new**
Date():object.getBirdthday()));

        table.put("office",
""+((object.getOffice()==**null**)?-1:object.getOffice().getId()));

        **return** table;

    }

}

**package** ua.kpi.lab111.LabDAO;

**import** java.sql.PreparedStatement;

**import** java.sql.ResultSet;

**import** java.sql.SQLException;

**import** java.text.SimpleDateFormat;

**import** java.util.ArrayList;

**import** java.util.Hashtable;

**import** java.util.List;

**import** ua.kpi.lab111.LabDAO.entity.Employee;

**import** ua.kpi.lab111.LabDAO.entity.Office;

/\*\*

\* DAO-объект для работы с таблицей офисов, синглтон

\*/

**public class** DAOOffice **extends** DAO\<Office\> {

    /\*\*

     \* Объект синглтона

     \*/

    **private static** DAOOffice *instance*;

    /\*\*

     \* Получить объект синглтона

     \* **\@return** синглтон

     \*/

    **public static synchronized** DAOOffice getInstance() {

        **if** (*instance* == **null**) {

            *instance* = **new** DAOOffice(Office.**class**);

        }

        **return** *instance*;

    }

    /\*\*

     \* Унаследованый конструктор

     \* **\@param** cls bean-класс

     \*/

    **protected** DAOOffice(Class\<Office\> cls) {

        **super**(cls);

    }

    /\*\*

     \* Поиск офисов по городу местонахождения

     \* **\@param** city название города

     \* **\@return** список результатов поиска

     \*/

    **public** List\<Office\> getByCity(String city) {

        PreparedStatement st;

        ArrayList\<Office\> list = **new** ArrayList\<Office\>();

        **try** {

            st = *getConn*().prepareStatement(

                    "SELECT \* FROM "+getTableName()+" WHERE city = ?;");

            st.setString(1, city);

            ResultSet set = read(st);

            **while** (set.next()) {

                Office office = **new** Office();

                list.add(office);

                fillObjectFields(office, set);

            }

        } **catch** (SQLException e) {

            e.printStackTrace();

        }

        **return** list;

    }

    \@Override

    **protected** String getTableName() {

        **return** "offices";

    }

    \@Override

    **protected void** fillObjectFields(Office obj, ResultSet set) **throws**
SQLException {

        obj.setId(set.getInt(1));

        obj.setAddress(set.getString(2));

        obj.setCity(set.getString(3));

    }

    \@Override

    **protected int** getObjectId(Office object) {

        **return** object.getId();

    }

    \@Override

    **protected void** setObjectId(Office object, **int** id) {

        object.setId(id);

    }

    \@Override

    **protected** Hashtable\<String,String\> makeKeyValues(Office object) {

        Hashtable\<String,String\> table = **new** Hashtable\<String,String\>();

        table.put("city", (object.getCity()==**null**)?"NULL":object.getCity());

        table.put("address",
(object.getAddress()==**null**)?"NULL":object.getAddress());

        **return** table;

    }

}

Створюється єдиний клас, який створює, записує та бере дані з bean-об’єктів за
допомогою рефлексії та передає їх в СКБД.

**package** ua.kpi.lab111.LabDAO;

**import** java.util.Date;

**import** java.util.List;

**import** ua.kpi.lab111.LabDAO.entity.\*;

/\*\*

\* Клиентский класс, который использует DAO-классы для работы с базой данных

\*

\*/

**public class** Client {

    /\*\*

     \* DAO-объект, через который можно оперировать с

     \* работниками в базе данных как с объектами Employee

     \*/

    **static** DAOEmployee *employees* = DAOEmployee.*getInstance*();

    /\*\*

     \* DAO-объект, через который можно оперировать с

     \* офисами в базе данных как с объектами Office.

     \*/

    **static** DAOOffice *offices* = DAOOffice.*getInstance*();

    /\*\*

     \* Метод, который ищет сотрудника в базе по его имени,

     \* а при отсутствии - создает его.

     \* **\@param** name имя работника

     \* **\@return** bean-объект работника Employee

     \*/

    **public static** Employee getEmployee(String name) {

        List\<Employee\> l = *employees*.getByName(name);

        **if** (l.size() \> 0) {

            **return** l.get(0);

        }

        Employee emp = *employees*.create();

        emp.setName(name);

        emp.setBirdthday(**new** Date());

        *employees*.update(emp);

        **return** emp;

    }

    /\*\*

     \* Метод, который ищет офис в базе по городу расположения,

     \* а при отсутствии - создает его.

     \* **\@param** city название города

     \* **\@param** num номер офиса в городе

     \* **\@return** bean-объект офиса Office

     \*/

    **public static** Office getOfficeInCity(String city, **int** num) {

        List\<Office\> l = *offices*.getByCity(city);

        **if** (l.size() \>= num) {

            **return** l.get(num-1);

        }

        Office office = *offices*.create();

        office.setCity(city);

        *offices*.update(office);

        **return** office;

    }

    /\*\*

     \* Пример работы с базой через DAO

     \* **\@param** args параметры коммандной строки

     \* **\@throws** Exception

     \*/

    **public static void** main(String args[]) **throws** Exception {

        Employee emp1 = *getEmployee*("Peter G.");

        Employee emp2 = *getEmployee*("George H.");

        Employee emp3 = *getEmployee*("John A.");

        Employee emp4 = *getEmployee*("Adams B.");

        Office off1 = *getOfficeInCity*("Kyiv", 1);

        off1.setAddress("Polytechnic street 1");

        Office off2 = *getOfficeInCity*("Kyiv", 2);

        off2.setAddress("Polytechnic street 5");

        *offices*.update(off1);

        *offices*.update(off2);

        emp1.setOffice(off1);

        emp2.setOffice(off2);

        emp3.setOffice(off1);

        emp4.setOffice(off2);

        *employees*.update(emp1);

        *employees*.update(emp2);

        *employees*.update(emp3);

        *employees*.update(emp4);

    }

}

**ЗАВДАННЯ**

1. Ознайомитись з призначенням шаблону Data Access Object

2. Створити базу даних у MySQL з двома таблицями

3. Створити bean-класи по одному для кожної таблиці, які складаються з опису
одного рядка таблиці.

4. Розробити DAO-інфраструктуру для роботи з базою даних через JDBC.

5. Розробити програму для тестування можливостей DAO, яка створює деякі об’єкти
в кожній таблиці та шукає існуючи їх по деяким ознакам.

6. Запустити програму та продивитись результати її роботи у MySQL.

**ПИТАННЯ ДЛЯ САМОСТІЙНОЇ ПЕРЕВІРКИ**

1. Яке основне призначення DAO

2. Які три основні можливі реалізації механізму в Java

3. Які переваги від розділення реалізації роботи з СКБД та прозорою роботою з
даними в програмі

# Розробка програмного застосунку з застосуванням мови Java

**МЕТА**

Розробка клієнт-серверного додатку на основі типового прикладу. Отримання
базових навичок із застосування шаблону Model-View-Controller.

**ДОВІДКА**

Абревіатура MVC розшифровується як Model-View-Controller
(Модель-Представлення-Контроллер). Це архітектура побудови програми, в рамках
якої вона поділяється на три компоненти:

Модель (Model) - надає дані для Представлення у відповідь на запити Контролера,
містить бізнес-логіку додатка.

Представлення (View) - відповідає за користувацький інтерфейс, відображає дані,
отримані від Моделі.

Контролер (Controller) - обробляє команди користувача, визначає Моделі для
роботи і пов'язує її з Представленням.

Бізнес-логіка, розташована в Моделі, включає всі правила і алгоритми, пов'язані
з предметною областю розв'язуваної задачі. Простіше кажучи - це ядро
створюваного додатка, яке може бути як банківським клієнтом, так і онлайн грою
або блогом.

Властивістю даної архітектури є те, що зміни в будь-якому з компонентів мають
мінімальний вплив на інші частини.

Дещо спрощуючи, роботу MVC додатка можна описати таким чином:

Команда (повідомлення про натискання кнопки, запиту адреси сайту і т. д.)
передається Контролеру;

Контролер, виходячи з отриманих даних, визначає і викликає Модель;

Модель, на основі закладеної в неї бізнес-логіки, формує набір даних;

Контролер вибирає Представлення і пов'язує його з даними (Моделлю);

Представлення відображає дані користувачеві.

**Залежності між компонентами шаблону**

Контролер грає роль сполучної ланки між Моделлю і Представленням. При цьому він
прагне якомога менше знати про подробиці їх реалізацій. Його завдання визначити
Модель для обробки отриманої команди і Представлення, яке буде отримувати
підсумкові дані.

Представлення, залежить від Моделі, так як покладається на отримувані від неї
дані.

Модель не залежить ні від Представлення ні від Контролера. Це дозволяє вести
розробку Моделі незалежно, а також створювати для неї кілька Представлень.

**Результат застосування MVC**

Зменшується залежність між частинами програми, що збільшує її гнучкість;

З'являється можливість розробляти тести для компонентів програми, тобто
використовувати техніку розробки через тестування (Test-Driven Development або
скорочено TDD).

**Помилки, при використанні MVC**

Деякі розробники помилково трактують Модель тільки як засіб доступу до бази
даних. У результаті бізнес-логіка переходить в Контролер, що в корені суперечить
архітектурі MVC.

Слід пам'ятати, що Модель це не тільки доступ до даних, а й логіка програми,
перевірка отриманих від користувача даних і т.д. У свою чергу, Контролер -
сполучна ланка між нею, Представленням і користувачем.

Іншою помилкою є спроба перенести всю логіку в Модель. Подібну помилку часто
можна зустріти при розробці веб-додатків. В цьому випадку Представлення
намагаються перетворити в простий шаблон, доступний для редагування будь якому
верстальщику. При цьому логіка елементів користувацького інтерфейсу з
Представлення переміщається в Модель або, іноді, в Контроллер.

Даний підхід помилковий з точки зору архітектури MVC, так як порушується чітке
розділення компонентів: Модель стає залежна від Представлення.

При правильному підході, Логіка користувацького інтерфейсу повинна знаходитися в
Представленнях. Але при цьому важливо коректно розділити її та бізнес-логіку.

**Приклад**

**public class** Model {

**public** List list() **throws** SQLException {

Connection connection = **null**;

PreparedStatement statement = **null**;

ResultSet resultSet = **null**;

List products = **new** ArrayList();

**try** {

>   connection = database.getConnection();

>   statement = connection.prepareStatement("SELECT id, name, description, price
>   FROM product");

>   resultSet = statement.executeQuery();

>   **while** (resultSet.next()) {

>   Product product = **new** Product();

>   product.setId(resultSet.getLong("id"));

>   product.setName(resultSet.getString("name"));

>   product.setDescription(resultSet.getString("description"));

>   product.setPrice(resultSet.getBigDecimal("price"));

>   products.add(product);

>   }

>   } **finally** {

>   **if** (resultSet != **null**) **try** { resultSet.close(); } **catch**
>   (SQLException ignore) {}

>   **if** (statement != **null**) **try** { statement.close(); } **catch**
>   (SQLException ignore) {}

>   **if** (connection != **null**) **try** { connection.close(); } **catch**
>   (SQLException ignore) {}

}

**return** products;

}

}

**public class** Controller **extends** HTTPServlet{

    **protected void** doGet(HttpServletRequest request, HttpServletResponse
response) **throws** ServletException, IOException {

     **try** {

     List products = productDAO.list();

     request.setAttribute("products", products); // Відображено як \${products} в
предсталенні

     request.getRequestDispatcher("/WEB-INF/products.jsp").forward(request,
response);

     } **catch** (SQLException e) {

     **throw new** ServletException("Cannot obtain products from DB", e);

     }

    }

}

\<%\@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %\>

...

\<table\>

\<c:forEach items="\${products}" var="product"\>

\<tr\>

\<td\>\${product.name}\</td\>

\<td\>\${product.description}\</td\>

\<td\>\${product.price}\</td\>

\</tr\>

\</c:forEach\>

\</table\>

**ЗАВДАННЯ**

Ознайомитись із архітектурними шаблонами проектування ПЗ. Знати загальну
характеристику та призначення архітектурних шаблонів.

Вивчити структуру та сфери застосування шаблону MVC.

Ознайомитись із структурою та призначенням елементів Model, Contoller та View:

-   розглянути їх функціональність та можливі помилки у використанні.

-   знати особливості реалізації кожного з елементів.

-   вільно володіти загальною структурою шаблону і структурою зв’язків між
    окремими елементами шаблону

-   вміти розпізнавати ознаки MVC на UML діаграмі класів та будувати вихідний
    код, що реалізує данний шаблон

Розробити прецеденти (use-cases) для системи, що розробляється (згідно
варіанту).

На основі прецедентів виділити дії, які мають бути реалізовані в якості команд
контролера. Скласти таблицю команд, що мають бути реалізованиі контролером, з їх
детальним описом.

Розробити архітектуру контролера на основі диспетчера Java Servlet та реалізацій
команд, що під'єднуються до контролера на етапі конфігурації.

Модифікувати результати попередньої лабораторної роботи для використання її в
якості Моделі.

Реалізувати контролер на основі Java Servlet. Розробити реалізації для всіх
команд.

**ПИТАННЯ ДЛЯ САМОСТІЙНОЇ ПЕРЕВІРКИ**

1.  У яких випадках варто використовувати MVC? Які переваги та недоліки він має?

2.  Як зв’язані між собою Model, Controller та View?

3.  Назвіть основні помилки у використанні шаблону MVC.

4.  Скільки реалізацій елемента View може бути представлено в додатку?

5.  У якому з елементів шаблону MVC слід організувати вивід елементів, що
    генерують події у відповідь на ті чи інші дії користувача (меню, кнопки,
    поля введення тощо)?

6.  У якому з елементів варто реалізувати методи, які забезпечували би
    отриманняі нформації з бази даних?

7.  У якому з елементів варто розмістити алгоритми обробки данних?

8.  В якості якого елемента архітектури MVC зазвичай використовується Java
    Servlet?

**ПРОТОКОЛ**

Протокол повинен містити титульну сторінку, завдання, роздруківку діаграми
прецедентів, список команд контроллера, розроблений програмний код та
згенеровану документацію в форматі JavaDoc.

**СПИСОК РЕКОМЕНДОВАНИХ ІНФОРМАЦІЙНИХ ДЖЕРЕЛ**

1.  [http](http://ru.wikipedia.org/wiki/Model-View-Controller)[://](http://ru.wikipedia.org/wiki/Model-View-Controller)[ru](http://ru.wikipedia.org/wiki/Model-View-Controller)[.](http://ru.wikipedia.org/wiki/Model-View-Controller)[wikipedia](http://ru.wikipedia.org/wiki/Model-View-Controller)[.](http://ru.wikipedia.org/wiki/Model-View-Controller)[org](http://ru.wikipedia.org/wiki/Model-View-Controller)[/](http://ru.wikipedia.org/wiki/Model-View-Controller)[wiki](http://ru.wikipedia.org/wiki/Model-View-Controller)[/](http://ru.wikipedia.org/wiki/Model-View-Controller)[Model](http://ru.wikipedia.org/wiki/Model-View-Controller)[-](http://ru.wikipedia.org/wiki/Model-View-Controller)[View](http://ru.wikipedia.org/wiki/Model-View-Controller)[-](http://ru.wikipedia.org/wiki/Model-View-Controller)[Controller](http://ru.wikipedia.org/wiki/Model-View-Controller)

2.  [http](http://www.chtivo.webhost.ru/articles/mvc.php)[://](http://www.chtivo.webhost.ru/articles/mvc.php)[www](http://www.chtivo.webhost.ru/articles/mvc.php)[.](http://www.chtivo.webhost.ru/articles/mvc.php)[chtivo](http://www.chtivo.webhost.ru/articles/mvc.php)[.](http://www.chtivo.webhost.ru/articles/mvc.php)[webhost](http://www.chtivo.webhost.ru/articles/mvc.php)[.](http://www.chtivo.webhost.ru/articles/mvc.php)[ru](http://www.chtivo.webhost.ru/articles/mvc.php)[/](http://www.chtivo.webhost.ru/articles/mvc.php)[articles](http://www.chtivo.webhost.ru/articles/mvc.php)[/](http://www.chtivo.webhost.ru/articles/mvc.php)[mvc](http://www.chtivo.webhost.ru/articles/mvc.php)[.](http://www.chtivo.webhost.ru/articles/mvc.php)[php](http://www.chtivo.webhost.ru/articles/mvc.php)

3.  [http](http://java.sun.com/blueprints/patterns/MVC.html)[://](http://java.sun.com/blueprints/patterns/MVC.html)[java](http://java.sun.com/blueprints/patterns/MVC.html)[.](http://java.sun.com/blueprints/patterns/MVC.html)[sun](http://java.sun.com/blueprints/patterns/MVC.html)[.](http://java.sun.com/blueprints/patterns/MVC.html)[com](http://java.sun.com/blueprints/patterns/MVC.html)[/](http://java.sun.com/blueprints/patterns/MVC.html)[blueprints](http://java.sun.com/blueprints/patterns/MVC.html)[/](http://java.sun.com/blueprints/patterns/MVC.html)[patterns](http://java.sun.com/blueprints/patterns/MVC.html)[/](http://java.sun.com/blueprints/patterns/MVC.html)[MVC](http://java.sun.com/blueprints/patterns/MVC.html)[.](http://java.sun.com/blueprints/patterns/MVC.html)[html](http://java.sun.com/blueprints/patterns/MVC.html)

4.  [Андрей](http://andrey.moveax.ru/)
    [](http://andrey.moveax.ru/)[Веселов](http://andrey.moveax.ru/).
    [Основы](http://andrey.moveax.ru/post/mvc3-in-depth-basics-01-mvc-template.aspx)[.](http://andrey.moveax.ru/post/mvc3-in-depth-basics-01-mvc-template.aspx)
    [Часть](http://andrey.moveax.ru/post/mvc3-in-depth-basics-01-mvc-template.aspx)
    [1
    -](http://andrey.moveax.ru/post/mvc3-in-depth-basics-01-mvc-template.aspx)
    [Шаблон](http://andrey.moveax.ru/post/mvc3-in-depth-basics-01-mvc-template.aspx)
    [](http://andrey.moveax.ru/post/mvc3-in-depth-basics-01-mvc-template.aspx)[MVC](http://andrey.moveax.ru/post/mvc3-in-depth-basics-01-mvc-template.aspx)
    [–](http://andrey.moveax.ru/post/mvc3-in-depth-basics-01-mvc-template.aspx)
    [http](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[://](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[www](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[.](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[berdaflex](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[.](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[com](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[/](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[ru](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[/](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[eclipse](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[/](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[books](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[/](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[rcp](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[\_](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[filemanager](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[/](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[ch](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[04](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[s](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[06.](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)[htm](http://www.berdaflex.com/ru/eclipse/books/rcp_filemanager/ch04s06.html)l

5.  Модель-вид-контролер
    [–](http://andrey.moveax.ru/post/mvc3-in-depth-basics-01-mvc-template.aspx)
    [http](http://uk.wikipedia.org/wiki/)[://](http://uk.wikipedia.org/wiki/)[uk](http://uk.wikipedia.org/wiki/)[.](http://uk.wikipedia.org/wiki/)[wikipedia](http://uk.wikipedia.org/wiki/)[.](http://uk.wikipedia.org/wiki/)[org](http://uk.wikipedia.org/wiki/)[/](http://uk.wikipedia.org/wiki/)[wiki](http://uk.wikipedia.org/wiki/)[/](http://uk.wikipedia.org/wiki/)Модель-вид-контролер

6.  [Загорцев](http://true-coder.ru/)
    [](http://true-coder.ru/)[Андрей](http://true-coder.ru/).[Разделение](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)
    [](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[кода](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)
    [](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[и](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)
    [](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[шаблона](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[,](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)
    [MVC](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)
    [—](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)
    [Часть](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)
    [](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[II](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)
    [](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[http](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[://](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[true](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[-](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[coder](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[.](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[ru](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[/](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[php](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[/](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[razdelenie](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[-](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[koda](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[-](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[i](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[-](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[shablona](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[-](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[mvc](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[-](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[chast](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[-2.](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)[html](http://true-coder.ru/php/razdelenie-koda-i-shablona-mvc-chast-2.html)
